package com.ionic.sdk.keyvault.utils;

import com.ionic.sdk.agent.key.KeyAttributesMap;
import com.ionic.sdk.agent.key.KeyObligationsMap;
import com.ionic.sdk.cipher.aes.AesCipher;
import com.ionic.sdk.core.codec.Transcoder;
import com.ionic.sdk.core.rng.CryptoRng;
import com.ionic.sdk.error.IonicException;
import com.ionic.sdk.error.SdkError;
import com.ionic.sdk.keyvault.KeyVaultKey;
import com.ionic.sdk.keyvault.KeyVaultTimeUtil;
import com.ionic.sdk.keyvault.KeyVaultInterface;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;
import java.util.Vector;

import org.junit.Assert;

/**
 * Utility functions for testing Key Vaults.
 */
public final class KeyVaultTestUtils {

    /**
     * Class scoped logger.
     */
    private static final Logger LOGGER = Logger.getLogger(KeyVaultTestUtils.class.getName());

    /**
     * Constructor.
     * http://checkstyle.sourceforge.net/config_design.html#FinalClass
     */
    private KeyVaultTestUtils() {
    }

    /**
     * Generates a random 256 bit key (32 bytes).
     * @return key as a byte[]
     * @throws IonicException if generated by random calls
     */
    public static byte[] generateRandomKeyBytes() throws IonicException {
        final CryptoRng rng = new CryptoRng();
        final byte[] keyBytes = new byte[AesCipher.KEY_BYTES];
        return rng.rand(keyBytes);
    }

    /**
     * Private constant - self-explanatory.
     */
    private static final short MIN_EXPIRE_TIME = 500;
    /**
     * Private constant - self-explanatory.
     */
    private static final short MAX_EXPIRE_TIME = 10000;

    /**
     * Generates a random time 5-10 seconds in the future.
     * @return Random time as seconds since the epoch
     * @throws IonicException if generated by random calls
     */
    public static long generateRandomExpirationUtcSeconds() throws IonicException {
        // generate random number of seconds to add to current time while
        // being sure that the expiration time will not be hit during this
        // regression test program
        final CryptoRng rng = new CryptoRng();
        return rng.randInt16(MIN_EXPIRE_TIME, MAX_EXPIRE_TIME) + KeyVaultTimeUtil.getCurrentServerTimeUtcSeconds();
    }

    /**
     * Compares two KeyVaults and asserts on failure.
     * @param vault1 vault to compare
     * @param vault2 vault to compare
     * @throws IonicException if generated by random calls
     */
    private static void compareVaultKeys(final KeyVaultInterface vault1,
                                         final KeyVaultInterface vault2) throws IonicException {

        Assert.assertEquals(vault1.getKeyCount(), vault2.getKeyCount());

        final Vector<KeyVaultKey> vecKeys1 = vault1.getAllKeys();
        Assert.assertNotNull(vecKeys1);

        for (KeyVaultKey key1 : vecKeys1) {
            final KeyVaultKey key2 = vault2.getKey(key1.getKeyId());
            Assert.assertNotNull(key2);
            Assert.assertTrue(key1.equals(key2));
        }
    }

    /**
     * Private constant - self-explanatory.
     */
    private static final long NUM_ISSUED_UTC_SECS_1 = 100;

    /**
     * Test a key vault using keys with attributes, saving and restoring to a vault copy.
     * Asserts on failures
     * @param vault vault to test
     * @param vaultCopy secondary vault to load from the first vault's save and check against
     * @param keyCount number of keys to test
     * @throws IonicException if generated by random calls
     */
    public static void testKeyVaultCrud(final KeyVaultInterface vault,
                                        final KeyVaultInterface vaultCopy,
                                        final int keyCount) throws IonicException {
        LOGGER.info(String.format("testKeyVaultCrud, keyCount=%d", keyCount));

        final KeyAttributesMap attrMap = new KeyAttributesMap();
        final List<String> keyAttr1 = new ArrayList<String>();
        final List<String> keyAttr2 = new ArrayList<String>();
        keyAttr1.add("keyAttr1_value1");
        keyAttr1.add("keyAttr1_value2");
        keyAttr2.add("keyAttr2_value1");
        attrMap.put("keyAttr1", keyAttr1);
        attrMap.put("keyAttr2", keyAttr2);

        final KeyAttributesMap mutableAttrMap = new KeyAttributesMap();
        final List<String> mutableKeyAttr1 = new ArrayList<String>();
        final List<String> mutableKeyAttr2 = new ArrayList<String>();
        mutableKeyAttr1.add("mutableKeyAttr1_value1");
        mutableKeyAttr1.add("mutableKeyAttr1_value2");
        mutableKeyAttr2.add("mutableKeyAttr2_value1");
        mutableAttrMap.put("mutableKeyAttr1", mutableKeyAttr1);
        mutableAttrMap.put("mutableKeyAttr2", mutableKeyAttr2);

        final KeyObligationsMap obligMap = new KeyObligationsMap();
        final List<String> keyOblig1 = new ArrayList<String>();
        final List<String> keyOblig2 = new ArrayList<String>();
        keyOblig1.add("keyOblig1_value1");
        keyOblig1.add("keyOblig1_value2");
        keyOblig2.add("keyOblig2_value1");
        obligMap.put("keyOblig1", keyOblig1);
        obligMap.put("keyOblig2", keyOblig2);

        // test new key insertion
        for (int i = 0; i < keyCount; ++i) {

            final String keyId = String.format("testKeyId_%d", (i + 1));
            final long nTimeoutUtcSecs = generateRandomExpirationUtcSeconds();
            final byte[] keyBytes = generateRandomKeyBytes();

            // add keyI to the expected key record map we use for validation of the real key vault
            final KeyVaultKey key = new KeyVaultKey(keyId, keyBytes, attrMap, mutableAttrMap,
                                                    obligMap, NUM_ISSUED_UTC_SECS_1, nTimeoutUtcSecs);
            Assert.assertEquals(vault.setKey(key, true), SdkError.ISKEYVAULT_OK);
        }

        LOGGER.info("testKeyVaultCrud, first sync");
        // sync main key vault with disk, persisting the key vault data to permanent
        // storage (may be file, keychain, etc).
        Assert.assertEquals(vault.getKeyCount(), keyCount);
        vault.sync();

        // use the second key vault to help test that sync() is working
        Assert.assertEquals(vaultCopy.getKeyCount(), 0);
        vaultCopy.sync();
        compareVaultKeys(vault, vaultCopy);

        // test key add and update

        // update a key (modify its key attributes and issued timestamp)
        // into main key vault
        final KeyVaultKey key1 = vault.getKey("testKeyId_1");
        Assert.assertNotNull(key1);
        List<String> attrList = key1.getKeyAttributes().get("keyAttr1");
        Assert.assertNotNull(attrList);
        attrList.remove(1);
        attrList = key1.getMutableKeyAttributes().get("mutableKeyAttr1");
        Assert.assertNotNull(attrList);
        attrList.remove(1);
        key1.setIssuedServerTimeUtcSeconds(key1.getIssuedServerTimeUtcSeconds() + 1);
        Assert.assertEquals(vault.setKey(key1, false), SdkError.ISKEYVAULT_OK);

        // add a new key into main key vault
        final KeyVaultKey key = new KeyVaultKey("newKeyId",
                                                generateRandomKeyBytes(),
                                                NUM_ISSUED_UTC_SECS_1,
                                                generateRandomExpirationUtcSeconds());
        Assert.assertEquals(vault.setKey(key, true), SdkError.ISKEYVAULT_OK);

        LOGGER.info("testKeyVaultCrud, update/add key sync");
        // sync main key vault with disk, sync second key vault with disk to get
        // the changes, and then ensure the vaults are still identical
        vault.sync();
        LOGGER.info("testKeyVaultCrud, update/add key sync copy");
        vaultCopy.sync();
        compareVaultKeys(vault, vaultCopy);

        // test remove single key

        // remove a key from main key vault
        final int nKeyCountBeforeRemove = vault.getKeyCount();
        Assert.assertEquals(vault.removeKey("testKeyId_2"), true);
        Assert.assertEquals(vault.getKeyCount(), (nKeyCountBeforeRemove - 1));

        LOGGER.info("testKeyVaultCrud, remove key sync");
        // sync main key vault with disk, sync second key vault with disk to get
        // the changes, and then ensure the vaults are still identical
        vault.sync();
        LOGGER.info("testKeyVaultCrud, remove key sync copy");
        vaultCopy.sync();
        compareVaultKeys(vault, vaultCopy);

        // test remove all keys

        // remove all keys from main key vault
        vault.clearAllKeys();
        Assert.assertEquals(vault.getKeyCount(), 0);

        LOGGER.info("testKeyVaultCrud, clear all keys sync");
        // sync main key vault with disk, sync second key vault with disk to get
        // the changes, and then ensure the vaults are still identical
        vault.sync();
        LOGGER.info("testKeyVaultCrud, clear all keys sync copy");
        vaultCopy.sync();
        compareVaultKeys(vault, vaultCopy);
    }

    /**
     * Private constant - self-explanatory.
     */
    private static final String CORRUPT_VAULT_STRING = "This is not a valid KeyVault file - not even close.\r\n";

    /**
     * Creates a file with text that should cause any vault reader to fail.
     * @param file file to create
     * @throws IonicException for any errors writing the file.
     */
    private static void writeCorruptFile(final File file) throws IonicException {

        try (FileOutputStream fos = new FileOutputStream(file)) {
            fos.write(Transcoder.utf8().decode(CORRUPT_VAULT_STRING));
            fos.close();
        } catch (FileNotFoundException e) {
            throw new IonicException(SdkError.ISKEYVAULT_OPENFILE, e);
        } catch (IOException e) {
            throw new IonicException(SdkError.ISKEYVAULT_OPENFILE, e);
        }
    }

    /**
     * Updates a file by adding a space to the end - assumes the file is from writeCorruptFile.
     * @param file file to create
     * @throws IonicException for any errors writing the file.
     */
    private static void updateCorruptFile(final File file) throws IonicException {

        try (FileOutputStream fos = new FileOutputStream(file, true)) {
            fos.write(' ');
            fos.close();
        } catch (FileNotFoundException e) {
            throw new IonicException(SdkError.ISKEYVAULT_OPENFILE, e);
        } catch (IOException e) {
            throw new IonicException(SdkError.ISKEYVAULT_OPENFILE, e);
        }
    }

    /**
     * Test a key vault can clear a corrupt file.
     * @param vault vault to test
     * @param file file the vault will try to sync from
     * @throws IonicException for any errors writing the file.
     */
    public static void testKeyVaultWithCorruptFile(final KeyVaultInterface vault,
                                                   final File file) throws IonicException {

        LOGGER.info(String.format("testKeyVaultWithCorruptFile path: %s.", file.getAbsolutePath()));
        // Create a new, corrupted file
        writeCorruptFile(file);

        try {
            vault.sync();
            Assert.assertTrue(false);
        } catch (IonicException e) {
            Assert.assertEquals(e.getReturnCode(), SdkError.ISKEYVAULT_NOHEADER);
        }

        // update the file because it needs a fresh modification time, or sync will ignore it.
        updateCorruptFile(file);

        try {
            vault.sync();
            Assert.assertTrue(false);
        } catch (IonicException e) {
            Assert.assertEquals(e.getReturnCode(), SdkError.ISKEYVAULT_NOHEADER);
        }

        // update the file because it needs a fresh modification time, or sync will ignore it.
        updateCorruptFile(file);

        vault.cleanVaultStore();
        vault.sync();
    }
}
