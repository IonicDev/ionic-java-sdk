package com.ionic.sdk.agent.cipher.file.family.generic.input;

import com.ionic.sdk.agent.cipher.file.data.FileCipher;
import com.ionic.sdk.agent.key.AgentKey;
import com.ionic.sdk.cipher.aes.AesCtrCipher;
import com.ionic.sdk.core.annotation.InternalUseOnly;
import com.ionic.sdk.crypto.CryptoUtils;
import com.ionic.sdk.error.IonicException;
import com.ionic.sdk.error.SdkData;
import com.ionic.sdk.error.SdkError;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Arrays;

/**
 * GenericFileCipher version 1.2 input extensions for handling the file body content.  These include handling the
 * file content signature stored at the beginning of the body.
 */
@InternalUseOnly
final class Generic12BodyInput implements GenericBodyInput {

    /**
     * The raw input data stream containing the protected file content.
     */
    private final BufferedInputStream sourceStream;

    /**
     * The cryptography key used to decrypt and verify the file content.
     */
    private final AgentKey key;

    /**
     * The Ionic cipher used to encrypt file blocks.
     */
    private final AesCtrCipher cipher;

    /**
     * A running buffer used to store block hashes.  These are hashed and signed at the completion of the
     * file crypto operation, and the result is prepended to the file content.
     */
    private final ByteArrayOutputStream plainTextBlockHashes;

    /**
     * Stored file signature, to be checked against the signature generated by reading the file content.
     */
    private byte[] hashOfHashesCipherText;

    /**
     * Constructor.
     *
     * @param sourceStream the raw input data containing the protected file content
     * @param key          the cryptography key used to decrypt and verify the file content
     * @throws IonicException on cipher initialization failures
     */
    Generic12BodyInput(final BufferedInputStream sourceStream, final AgentKey key) throws IonicException {
        this.sourceStream = sourceStream;
        this.key = key;
        cipher = new AesCtrCipher();
        cipher.setKey(key.getKey());
        this.plainTextBlockHashes = new ByteArrayOutputStream();
    }

    /**
     * The v1.2 streaming cipher needs to set aside the file signature, so that it may be verified after all
     * of the file data is read.
     *
     * @throws IonicException on failure reading from the stream
     */
    @Override
    public void init() throws IonicException {
        final byte[] cipherText = new byte[FileCipher.Generic.V12.SIGNATURE_SIZE_CIPHER];
        try {
            final int count = sourceStream.read(cipherText);
            SdkData.checkTrue((FileCipher.Generic.V12.SIGNATURE_SIZE_CIPHER == count), SdkError.ISFILECRYPTO_EOF);
        } catch (IOException e) {
            throw new IonicException(SdkError.ISFILECRYPTO_EOF, e);
        }
        hashOfHashesCipherText = cipherText;
    }

    /**
     * Read the next Ionic-protected block from the input stream.
     *
     * @return the next plainText block extracted from the stream
     * @throws IOException    on failure reading from the stream
     * @throws IonicException on failure to decrypt the block, or calculate the block signature
     */
    @Override
    public byte[] read() throws IOException, IonicException {
        final byte[] block = new byte[FileCipher.Generic.V12.BLOCK_SIZE_CIPHER];
        final int blockSize = sourceStream.read(block);
        final byte[] cipherTextBlock = Arrays.copyOf(block, blockSize);
        final byte[] plainTextBlock = cipher.decrypt(cipherTextBlock);
        final byte[] plainTextBlockHash = CryptoUtils.hmacSHA256(plainTextBlock, key.getKey());
        plainTextBlockHashes.write(plainTextBlockHash);
        return plainTextBlock;
    }

    /**
     * Finish processing of the input stream.
     *
     * @throws IonicException on failure to verify the file signature
     */
    @Override
    public void doFinal() throws IonicException {
        final byte[] hashOfHashesExpected = cipher.decrypt(hashOfHashesCipherText);
        final byte[] hashOfHashesActual = CryptoUtils.hmacSHA256(plainTextBlockHashes.toByteArray(), key.getKey());
        final boolean verified = Arrays.equals(hashOfHashesExpected, hashOfHashesActual);
        SdkData.checkTrue(verified, SdkError.ISFILECRYPTO_HASH_VERIFICATION);
    }
}
