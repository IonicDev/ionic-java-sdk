package com.ionic.sdk.agent.cipher.file.family.generic.input;

import com.ionic.sdk.agent.cipher.file.data.FileCipher;
import com.ionic.sdk.agent.key.AgentKey;
import com.ionic.sdk.cipher.aes.AesCtrCipher;
import com.ionic.sdk.core.annotation.InternalUseOnly;
import com.ionic.sdk.crypto.CryptoUtils;
import com.ionic.sdk.error.IonicException;
import com.ionic.sdk.error.SdkData;
import com.ionic.sdk.error.SdkError;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.util.Arrays;

/**
 * GenericFileCipher version 1.2 input extensions for handling the file body content.  These include handling the
 * file content signature stored at the beginning of the body.
 */
@InternalUseOnly
final class Generic12BodyInput implements GenericBodyInput {

    /**
     * The raw input data stream containing the protected file content.
     */
    private final BufferedInputStream sourceStream;

    /**
     * The cryptography key used to decrypt and verify the file content.
     */
    private final AgentKey key;

    /**
     * The buffer to hold a plaintext block (source buffer for encryption, target buffer for decryption).
     */
    private final ByteBuffer plainText;

    /**
     * The buffer to hold a ciphertext block (source buffer for decryption, target buffer for encryption).
     */
    private final ByteBuffer cipherText;

    /**
     * The Ionic cipher used to encrypt file blocks.
     */
    private final AesCtrCipher cipher;

    /**
     * A running buffer used to store block hashes.  These are hashed and signed at the completion of the
     * file crypto operation, and the result is prepended to the file content.
     */
    private final ByteArrayOutputStream plainTextBlockHashes;

    /**
     * Stored file signature, to be checked against the signature generated by reading the file content.
     */
    private byte[] hashOfHashesCipherText;

    /**
     * Constructor.
     *
     * @param sourceStream the raw input data containing the protected file content
     * @param key          the cryptography key used to decrypt and verify the file content
     * @param plainText    ByteBuffer to receive the result of the cryptography operation
     * @param cipherText   ByteBuffer containing bytes to decrypt
     * @throws IonicException on cipher initialization failures
     */
    Generic12BodyInput(final BufferedInputStream sourceStream, final AgentKey key,
                       final ByteBuffer plainText, final ByteBuffer cipherText) throws IonicException {
        this.sourceStream = sourceStream;
        this.plainText = plainText;
        this.cipherText = cipherText;
        this.key = key;
        this.cipher = new AesCtrCipher();
        if (key != null) {
            this.cipher.setKey(key.getKey());
        }
        this.plainTextBlockHashes = new ByteArrayOutputStream();
    }

    /**
     * The v1.2 streaming cipher needs to set aside the file signature, so that it may be verified after all
     * of the file data is read.
     *
     * @throws IonicException on failure reading from the stream
     */
    @Override
    public void init() throws IonicException {
        final byte[] bytesCipherText = new byte[FileCipher.Generic.V12.SIGNATURE_SIZE_CIPHER];
        try {
            final int count = sourceStream.read(bytesCipherText);
            SdkData.checkTrue((FileCipher.Generic.V12.SIGNATURE_SIZE_CIPHER == count), SdkError.ISFILECRYPTO_EOF);
        } catch (IOException e) {
            throw new IonicException(SdkError.ISFILECRYPTO_EOF, e);
        }
        hashOfHashesCipherText = bytesCipherText;
    }

    @Override
    public ByteBuffer read() throws IOException, IonicException {
        // consume input data
        final ReadableByteChannel readableChannel = Channels.newChannel(sourceStream);
        cipherText.clear();
        final int blockSize = readableChannel.read(cipherText);
        // perform decryption
        cipherText.limit(blockSize);
        cipherText.position(0);
        if (key != null) {
            cipher.decrypt(plainText, cipherText);
        }
        // verify block
        plainText.limit(plainText.position());
        plainText.position(0);
        if (key != null) {
            final byte[] plainTextBlockHash = CryptoUtils.hmacSHA256(plainText, key.getKey());
            plainTextBlockHashes.write(plainTextBlockHash);
        }
        // wrap up processing
        plainText.limit(plainText.position());
        plainText.position(0);
        return plainText;
    }

    /**
     * Finish processing of the input stream.
     *
     * @throws IonicException on failure to verify the file signature
     */
    @Override
    public void doFinal() throws IonicException {
        final byte[] hashOfHashesExpected = cipher.decrypt(hashOfHashesCipherText);
        final byte[] hashOfHashesActual = CryptoUtils.hmacSHA256(plainTextBlockHashes.toByteArray(), key.getKey());
        final boolean verified = Arrays.equals(hashOfHashesExpected, hashOfHashesActual);
        SdkData.checkTrue(verified, SdkError.ISFILECRYPTO_HASH_VERIFICATION);
    }
}
